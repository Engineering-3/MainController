
<!-- saved from url=(0041)http://www.surveyor.com/SRV_protocol.html -->
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
        <link rel="stylesheet" href="./Definition of the SRV-1 Control Protocol (Blackfin Version) GCCv2_0_files/style_product.css" type="text/css">
        <title>Definition of the SRV-1 Control Protocol (Blackfin Version)</title>
    </head>
<body>
<a href="http://www.surveyor.com/"><img src="./Definition of the SRV-1 Control Protocol (Blackfin Version) GCCv2_0_files/surveyor.gif" border="0"></a><br>

<h3>Definition of the SRV-1 GCC v2.0 Control Protocol (Blackfin Version) - as of October 2011</h3>

<table>
    <tbody>
        <tr>
            <td>
                All commands from the host to the SRV-1 robot are comprised of ASCII characters or ASCII followed by 8-binary or ASCII decimal characters.  All commands receive an acknowledgment from the robot to the host, which is either a '#' character followed by the command, or '##' for variable length responses. Variable length commands which don't specify a return size append a CR + newline ('\r\n') to their response.
            </td>
        </tr>
        <tr>
            <td></td>
        </tr>
        <tr>
            <td>
                Note that many of these commands can be executed via a terminal program with TCP / telnet capability. Those commands that require binary arguments will not work this way unles your telnet program can generate arbitrary binary bytes. For example, you can connect using the 'netcat' command via
            </td>
        </tr>
        <tr>
            <td>
                <code>nc robot-ip 10001</code>
            </td>
        </tr>
        <tr>
            <td></td>
        </tr>
        <tr>
            <td>
                When the robot first powers up, it will dump the 'V' Version command results ("##Version ...\r\n") so you can see what version of firmware is running. There is typically a 2 second delay after startup before the robot can accept any commands while the camera and other sensors are initialized - you should see the yellow LED's flash when the processor reboots. After startup, just to test that there is 2-way communication, send an 'V' to access the firmware version string. The only command that will produce strange results is the 'I' IMJ command, which grabs a JPEG frame - this will flood the screen with binary characters. However, other commands may return a limited number of binary (non-printable ASCII) bytes.
            </td>
        </tr>
        <tr>
            <td></td>
        </tr>
        <tr>
            <td>
                The firmware has a built-in C interpreter called "picoC".  The 'Q' command will execute the C program that has been stored in the robot's flash buffer and the '!' command will run C interactively, terminated with an ESC.  The flash buffer can be set by the 'zr' command which transfers the contents of the user flash segment to the flash buffer, or via the 'X' command which transfers a file from the host via XMODEM protocol.  Before executing a program, the contents of the flash buffer can be examined using 'zd'.  When the program finishes (assuming the C program isn't running an infinite loop), control returns to the C interpreter, unless the exit() function is called in the C program, which similar to ESC returns control to the regular SRV-1 command processing loop.  If the autorun(x) function is placed at the beginning of a program which is stored in flash sector #4, the robot will start running the stored C program unless ESC character is received within 'x' seconds of startup.
            </td>
        </tr>
        <tr>
            <td></td>
        </tr>
        <tr>
            <td>
                If there are any questions about this protocol, send email to <a href="mailto:support@surveyor.com" support@surveyor.com</a> or check the <a href="http://www.surveyor.com/robot_forum.html">Surveyor Robotics Forum</a>.
            </td>
        </tr>
        <tr>
            <td></td>
        </tr>
    </tbody>
</table>
<br>
<br>
<table border="1">
    <tbody>
        <tr>
            <th>Command</th>
            <th>Response</th>
            <th>Description</th>
        </tr>
        <tr>
            <th></th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th>Core Robot Commands</th>
            <th></th>
            <th></th>
        </tr>
        <tr>
            <th></th>
            <th></th>
            <th></th>
        </tr><tr><td>'7'</td><td>'#7'</td><td>note that keypad commands ('1' - '9') don't become active until an 'Mxxx' motor control command has been received<br><br>robot drift left
</td></tr><tr><td>'8'</td><td>'#8'</td><td>robot drive forward
</td></tr><tr><td>'9'</td><td>'#9'</td><td>robot drift right
</td></tr><tr><td>'4'</td><td>'#4'</td><td>robot drive left
</td></tr><tr><td>'5'</td><td>'#5'</td><td>robot stop
</td></tr><tr><td>'6'</td><td>'#6'</td><td>robot drive right
</td></tr><tr><td>'1'</td><td>'#1'</td><td>robot back left
</td></tr><tr><td>'2'</td><td>'#2'</td><td>robot drive back
</td></tr><tr><td>'3'</td><td>'#3'</td><td>robot back right
</td></tr><tr><td>'0'</td><td>'#0'</td><td>robot rotate left 20-deg
</td></tr><tr><td>'.'</td><td>'#.'</td><td>robot rotate right 20-deg
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'+'</td><td>'#+'</td><td>increase motor/servo level
</td></tr><tr><td>'-'</td><td>'#-'</td><td>decrease motor/servo level
</td></tr><tr><td>'&lt;'</td><td>'#&lt;'</td><td>trim motor balance toward left
</td></tr><tr><td>'&gt;'</td><td>'#&gt;'</td><td>trim motor balance toward right
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'a'</td><td>'#a'</td><td>set capture resolution to 160x120
</td></tr><tr><td>'b'</td><td>'#b'</td><td>set capture resolution to 320x240
</td></tr><tr><td>'c'</td><td>'#c'</td><td>set capture resolution to 640x480
</td></tr><tr><td>'d' or 'A'</td><td>'#A'</td><td>set capture resolution to 1280x1024
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'D'</td><td>'##D'</td><td>checks MN13812 battery level detect circuit on SVS<br>
returns:<br>
##D - battery voltage okay<br>
##D - low battery voltage detected<br>
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'E'</td><td></td><td>launches flash buffer line editor -<br>
(T)op (B)ottom (P)reviouse (N)ext line (L)ist (I)nsert until ESC (D)elete (H)elp (X)exit
</td></tr><tr><td>'Fab'</td><td>'#F'</td><td>Enables Failsafe mode for motor control<br>
'ab' parameters sent as 8-bit binary<br><br>
a = left motor/servo failsafe level, b = right motor/servo failsafe level.<br><br>
sets motor/servo levels for 'M' and 'S' commands in case no command is received via the radio link within 2 seconds.  
</td></tr><tr><td>'f'</td><td>'#f'</td><td>disables Failsafe mode
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'G'</td><td>HTML stream</td><td>HTTP GET command - parses HTTP request, e.g.<br>
GET /index.html HTTP/1.1 <br><br>
- recognizes files /00.html .. /09.html, stored respectively in flash sectors 10/11, 12/13 .. 28/29 <br><br>
- /index.html == /00.html<br><br>
- will replace "$$camera$$" with base64 live captured JPEG <br><br>
- use 'zBxx' to store in sector pair - zb10 stores 128kB from flash buffer to sectors 10/11<br>
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'I'</td><td>'##IMJxs0s1s2s3....'</td><td>grab JPEG compressed video frame
<br><br> x = frame size in pixels:<br>   1 = 80x64, 3 = 160x120, 5 = 320x240, 7 = 640x480, 9 = 1280x1024
<br><br> s0s1s2s3=frame size in bytes (s0 * 256^0 + s1 * 256^1 + s2 * 256^2 + s3 * 256^3)
	<br> .... = full JPEG frame
	<br><br> Note that sometimes the 'I' command returns nothing if the
	robot camera is busy, so the 'I' command should be called as many times
	as needed until a frame is returned
	</td>
</tr>
<tr>
	<td>'irab'</td>
	<td>'##irhh cc'</td>
	<td>I2C register read ('ab' parameters sent as 8-bit binary)<br>
	'aa is device id (one binary byte), 'b' is register (one binary byte), 'hh' is the ASCII HEX represnetation of 'a' (always two characters) 'cc' is 8-bit return value from register displayed as decimal value, which could be one, two or three characters long, and there is a <CR><LF> pair of bytes at the end. The <CR><LF> can be used to know that the variable length 'cc' is complete.
	</td>
</tr>
<tr>
	<td>'iRab'</td>
	<td>'##iRhh cc'</td>
	<td>I2C register read ('ab' parameters sent as 8-bit binary)<br>
	'a' is device id, 'b' is register, 'hh' is the ASCII HEX represnetation of 'a' (always two characters), 'cc' is 16-bit return value from register displayed as decimal value, which could be from one to five characters long, and there is a <CR><LF> pair of bytes at the end. The <CR><LF> can be used to know that the variable length 'cc' is complete.
	</td>
</tr>
<tr>
	<td>'iMabc'</td>
	<td>'##iMaa xx xx ... xx'</td>
	<td>I2C multiple register read ('abc' parameters sent as 8-bit binary)<br>
	a is device id, b is register, c is count, xx is 8-bit return values from register displayed as decimal value
	</td>
</tr>
<tr>
	<td>'iwabc'</td>
	<td>'##iwaa'</td>
	<td>I2C register write ('abc' parameters sent as 8-bit binary)<br>
	a is device id, b is register, c is value written to register
	</td>
</tr>
<tr>
	<td>'iWabcd'</td>
	<td>'##iWaa'</td>
	<td>multi-byte I2C register write ('abcd' parameters sent as 8-bit binary)<br>
	a is device id, b is first byte, c is second byte, d is third byte
	</td>
</tr>
<tr>
	<td>'idabcef'</td>
	<td>'##idaa'</td>
	<td>I2C dual register write ('abcde' parameters sent as 8-bit binary)<br>
	a is device id, b is register 1, c is value written to register 1, d is register 2, e is value written to register 2
	</td>
</tr>
<tr>
	<th></th>
	<th></th>
	<th></th>
	</tr><tr>
	<td>'l'</td><td>'#l'</td><td>turn on lasers
</td></tr><tr><td>'L'</td><td>'#L'</td><td>turn off lasers
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'Mabc'</td><td>'#M'</td><td>direct motor control<br>
'abc' parameters sent as 8-bit binary<br>
<br> a=left speed, b=right speed, c=duration*10milliseconds
<br><br> speeds are 2's complement 8-bit binary values - 0x00 through 0x7F is
forward, 0xFF through 0x81 is reverse, e.g. the decimal equivalent of the 4-byte sequence 0x4D 0x32
0xCE 0x14 = 'M' 50 -50 20 (rotate right for 200ms)
<br><br> duration of 00 is infinite, e.g. the 4-byte sequence 0x4D 0x32 0x32 0x00 = M 50 50 00 (drive forward at 50% indefinitely)
</td></tr><tr><td>'mabc'</td><td>'#m'</td><td>to employ direct PWM motor control of 2nd bank of timers (TMR6 and TMR7) - same format as 'M' command<br>
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'o'</td><td>'#o'</td><td>enable caption overlay
</td></tr><tr><td>'O'</td><td>'#O'</td><td>disable caption overlay
</td></tr><tr><td>'p'</td><td>'##ping xxxx xxxx xxxx xxxx\r\n'</td><td>ping ultrasonic ranging modules attached to pins 27, 28, 29, 30 with trigger on pin 18 - tested with Maxbotics EZ0 and EZ1 modules.  xxxx return value is range in inches * 100 (2500 = 25 inches)
</td></tr><tr><td>'qx'</td><td>'##quality x\r\n'</td><td>sets JPEG quality between 1-8 ('x' is an ASCII decimal character).  1 is highest, 8 is lowest
</td></tr><tr><td>'R'</td><td>'##Range(cm) = xxx'</td><td>measure range to nearest obstacle using laser pointers
</td></tr><tr><td>'r'</td><td>'##Range(cm)'</td><td>same as 'R', but with lots of diagnostic output
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'Sab'</td><td>'#S'</td><td>direct servo control (TMR2 and TMR3) <br>
'ab' parameters sent as 8-bit binary<br><br>
a=left servo setting (0x00-0x64), b=right servo setting (0x00-0x64)
<br><br> servo settings are 8-bit binary values, representing timing pulse widths ranging from 1ms to 2ms.  0x00 corresponds to a 1ms pulse, 0x64 corresponds to a 2ms pulse, and 0x32 is midrange with a 1.5ms pulse
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'sab'</td><td>'#s'</td><td>direct servo control of 2nd bank of servos (TMR6 and TMR7)<br>
'ab' parameters sent as 8-bit binary<br><br>
a=left servo setting (0x00-0x64), b=right servo setting (0x00-0x64)
<br><br> servo settings are 8-bit binary values, representing timing pulse widths ranging from 1ms to 2ms.  0x00 corresponds to a 1ms pulse, 0x64 corresponds to a 2ms pulse, and 0x32 is midrange with a 1.5ms pulse
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'t'</td><td>'##time - millisecs: xxxx\r\n'</td><td>outputs time in milliseconds since reset
</td></tr><tr><td>'Tx'</td><td>'#T'</td><td>changes threshold in 'g2' edge detection - T4 is default, range is T1 to T9
</td></tr><tr><th></th><th></th><th>
</th></tr>
<tr>
    <td>'V'</td>
    <td>'##Version ...\r\n'</td>
    <td>
        read firmware version info
        <br>
        response is terminated by newline character
    </td>
</tr>
<tr>
    <td>0x1F (binary byte)</td>
    <td>'##Version ...\r\n'</td>
    <td>
        Returns version string, but does so without a surrounding packet, even if packet mode is turned on.
    </td>
</tr>
<tr><td>'X'</td><td>'#Xmodem transfer count: bytes'</td><td>Xmodem-1K file transfer - receive file via xmodem protocol - store in flash buffer
</td></tr><tr><td>'y'</td><td>'#y'</td><td>flip video capture (for use with upside-down camera)
</td></tr><tr><td>'Y'</td><td>'#Y'</td><td>restore video capture to normal orientation
</td></tr><tr><td>'zAxx'</td><td>'##zA - read 131072 bytes\r\n'</td><td>flash memory large read - read 128kb from specified flash sector pair xx 02/03 ... 62/63 to flash buffer (e.g. read C program from flash sector before running C interpreter).  Sectors 00 and 01 are off-limits.
</td></tr><tr><td>'zBxx'</td><td>'##zB - wrote 131072 bytes\r\n'</td><td>flash memory large write - write 128kb from flash buffer to specified flash sector buffer pair 02/03 ... 62/63 (sectors 00 and 01 are off-limits)
</td></tr><tr><td>'zc'</td><td>'##zclear\r\n'</td><td>clear contents of flash buffer
</td></tr><tr><td>'zC'</td><td>'##zCRC xxxx\r\n'</td><td>compute crc16_ccitt for flash buffer
</td></tr><tr><td>'zd'</td><td>'##zd...\r\n'</td><td>flash buffer dump - dump contents of flash memory buffer to console
</td></tr><tr><td>'zr'</td><td>'##zr\r\n'</td><td>flash memory read - read 65kb from user flash sector to flash buffer (e.g. read C program from flash sector before running C interpreter)
</td></tr><tr><td>'zRxx'</td><td>'##zRead\r\n'</td><td>flash memory read - read 65kb from specified flash sector xx (02 - 63) to flash buffer (e.g. read C program from flash sector before running C interpreter).  Sectors 00 and 01 are off-limits.
</td></tr><tr><td>'zw'</td><td>'##zw\r\n'</td><td>flash memory write - write 65kb from flash buffer to user flash sector
</td></tr><tr><td>'zWxx'</td><td>'##zWxx\r\n'</td><td>flash memory write - write 65kb from flash buffer to specified flash sector 02-63 (sectors 00 and 01 are off-limits)
</td></tr><tr><td>'zZ'</td><td>'##zZ\r\n'</td><td>flash memory boot sector update - writes contents of flash buffer to boot sectors of flash memory - used to replace u-boot.ldr or srv1.ldr - checks first that a valid LDR format image is in the flash buffer
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><th></th><th></th><th>

</th></tr><tr><th>Special Commands</th><th></th><th>
</th></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'$!'</td><td></td><td>reset Blackfin
</td></tr><tr><td>'$E'</td><td></td><td>read optional wheel encoders on GPIO-H14 and H15
</td></tr><tr><td>'$ex'</td><td></td><td>x = motor # (1-4);  read cummulative pulse count from wheel encoder on SRV-4WD
</td></tr><tr><td>'$g'</td><td></td><td>parse GPS input
</td></tr><tr><td>'$R'</td><td></td><td>SVS command - configures slave Blackfin to receive SPI transfer to flash buffer
</td></tr><tr><td>'$X'</td><td></td><td>SVS command - configures master Blackfin to transfer contents of flash buffer via SPI
</td></tr><tr><td>'$Axx'</td><td>'##$Axx yyyy\r\n'</td><td>read AD7998 A/D channel xx (01-08, 11-18 or 21-28)
</td></tr><tr><td>'$C'</td><td>'##$C xxx\r\n'</td><td>read HMC6352 compass
</td></tr><tr><td>'$c'</td><td>'##c heading=344  x=-505 y=-110 z=447  xmin=-1032 xmax=-228 ymin=-970 ymax=-89\r\n'</td><td>read HMC5843 compass
</td></tr><tr><td>'$Ta'</td><td>'##$Tx yyyy\r\n'</td><td>read LIS3LV02DQ tilt sensor channel a (1 = x axis, 2 = y axis, 3 = z axis)
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><th></th><th></th><th>

</th></tr><tr><th>Vision Commands</th><th></th><th>
</th></tr><tr><th></th><th></th><th>
</th></tr><tr><td>all parameters are sent as ASCII decimal characters ('0' - '9')</td><td></td><td>
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'g0'</td><td>'##g0'</td><td>grab reference frame and enable frame differencing
</td></tr><tr><td>'g1'</td><td>'##g1'</td><td>enable color segmentation
</td></tr><tr><td>'g2'</td><td>'##g2'</td><td>enable edge detection (threshold changed with 'T' command)
</td></tr><tr><td>'g3'</td><td>'##g3'</td><td>enable horizon detection (threshold changed with 'T' command)
</td></tr><tr><td>'g4'</td><td>'##g4'</td><td>enable obstacle detection (threshold changed with 'T' command)
</td></tr><tr><td>'g5'</td><td>'##g5'</td><td>enable stereo processing (only works with SVS that has GPIO-H8 connection between processors)
</td></tr><tr><td>'g6x'</td><td>'##g6 bin# x'</td><td>graphically overlay blob search results for color bin# x (e.g. 'g63' displays blobs matching color bin 3)
</td></tr><tr><td>'g_'</td><td>'#g_'</td><td>disable frame differencing / color segmentation / edge detection. 
the '_' in 'g_' could be any character other than 0, 1, 2, 3, 4
</td></tr><tr><th></th><th></th><th>
</th></tr><tr><td>'vax'</td><td>'##vax\r\n'</td><td>the 'va' command enables/disables automatic gain, white balance and exposure camera functions (default x=7)<br>  x=4 -&gt; AGC enable<br> x=2 -&gt; AWB enable<br> x=1 -&gt; AEC enable<br>  x=7 -&gt; AGC+AWB+AEC on<br>  x=0 -&gt; AGC+AWB+AEC off
</td></tr><tr><td>'vbc'</td><td>'##vbc dd\r\n ssss x1 x2 y1 y2\r\n ....'</td><td>the
'vb' command searches for blobs matching the colors in color bin #c, indicates the number of blobs found as dd,
and returns a count of matching pixels
in the blob, along with coordinates of an x1, x2, y1, y2 rectangular region
containing the matching pixels. up to 16 blobs can be returned, and the blobs are sent in
order of pixel count, though blobs smaller than MIN_BLOB_SIZE
(currently set to 5 pixels) aren't shown.
</td></tr><tr><td>'vccy1y2u1u2v1v2'</td><td>'##vcc\r\n'</td><td>the 'vc' command directly sets the contents of color bin #c.  <br>
this command will return string with 'vc' followed by the color bin number.  <br>
for example, we could save a set of colors to color bin #3
corresponding to measurements taken at another time, such as the above
mentioned orange golf ball color measurement, using 'vc3127176086111154200'.
we could then confirm that the colors were properly stored by issuing
the command 'vr3' to retrieve the contents of color bin #3.
</td></tr><tr><td>'vfxxx1xxx2yyy1yyy2'</td><td>'##vf xxxx\r\n'</td><td>the 'vf' counts the number of pixels matching color bin #c in the range of x1, x2, y1, y2<br>
e.g.  'vf10100020001500220'  searches for color bin #1 pixels in the x range from 100-200 and y range from 150-220 <br>
</td></tr><tr><td>'vh'</td><td>'##vhist y  u  v\r\n'</td><td>computes and lists the distribution of Y, U and V pixels over the entire range of possible values, divided into bins of 0-3, 4-7, 8-11, ... 248-251, 252-255
</td></tr><tr><td>'vm'</td><td>'##vmean yy uu vv\r\n'</td><td>computes mean values for Y, U and V over the entire image.
</td></tr><tr><td>'vpxxxxyyyy'</td><td>'##vp yyy uuu vvv\r\n'</td><td>the 'vp' command samples a single pixel defined by coordinates xxxx (column 0000-0159, 0000-0319, 0000-0639, 0000-1279 depending on resolution) and yy (row 0000-0127, 0000-0255, 0000-0511, 0000-1023, where 0000 is top of image). 'vp01600128' will sample a pixel in the middle of the image at 320x256 resolution, 'vp01600000' will sample a pixel in the middle of the top row, etc...
</td></tr><tr><td>'vrc'</td><td>'##vrc y1 y2 u1 u2 v1 v2\r\n'</td><td>the 'vr' command retrieves the stored color info from color bin #c.  <br>this command will return string with 'vr' followed by the color bin number,
followed by y1=Ymin, y2=Ymax, u1=Umin, u2=Umax, v1=Vmin, v2=Vmax. <br>
in the above example where colors for an orange golf ball were captured
using the 'vg' command for color bin #0, issuing a 'vr0' command will
return the colors stored in color bin #0 - e.g. '##vr0 127 176 86 111 154 200\r\n'. 
</td></tr><tr><td>'vsx'</td><td>'##vscan = pix xxxx xxxx xxxx xxxx ... xxxx\r\n'</td><td>vs scans for edge pixels in x (1-9) columns using edge_thresh set by 'T' or 'vt' command.  displays total number of edge pixels found and distance from bottom to first edge pixel in each column
</td></tr><tr><td>'vtxxx'</td><td>'##vthresh xxxx\r\n'</td><td>vt sets the edge_thresh global variable from 0000-9999 for edge detection (default is 3200).  equivalent to 'T' console function but with more precision
</td></tr><tr><td>'vzx'</td><td>'##vzero\r\n'</td><td>vz0 zeros out all of the color bins, vz1 / vz2 / vz3 / vz4 segments colors into various color spaces which can be used by enabling 'g1' color segmentation function ('G' turns it off)</td></tr>
<tr><th></th><th></th><th></th></tr>
<tr><th>Neural Network Commands</th><th></th><th></th></tr>
<tr><th></th><th></th><th></th></tr>
<tr><td>all parameters are sent as ASCII hex characters ('0' - 'f')</td><td></td><td></td></tr>
<tr><th></th><th></th><th></th></tr>
<tr><td>'np'</td><td></td><td>store a new pattern</td></tr>
<tr><td>'nd'</td><td></td><td>display a stored pattern</td></tr>
<tr><td>'ni'</td><td></td><td>initialize the network with random weights</td></tr>
<tr><td>'nt'</td><td></td><td>train the network from stored patterns</td></tr>
<tr><td>'nx'</td><td></td><td>test the network with sample pattern</td></tr>
<tr><td>'ng'</td><td></td><td>grab a pattern using blob located by "vb"</td></tr>
<tr><td>'nb'</td><td></td><td>match pattern against specific blob from "vb"</td></tr>

<tr><th></th><th></th><th></th></tr>

<tr>
	<th>New commands for GCC v2.0 SRV firmware version</th><th></th><th></th>
</tr>
<tr>
    <td>'ibxxyyz'</td>
    <td>'##ib xx yy z v\r\n'</td>
    <td>
        <b>Read One Bit From I2C Register</b><br>
        <b>Command:</b>'ibxxyyz'<br>
            xx is a two character ASCII hexadecimal value from 00 to FF representing the I2C address<br>
            yy is a two character ASCII hexadecimal value from 00 to FF representing the I2C register<br>
            z is a one character ASCII hexadecimal value from 0 to 7 representing the bit to be read<br>
            example: "ib327F3" would request a read of the 3rd bit of register 0x7F from I2C address 0x32<br>
        <b>Response:</b>'##ib xx yy z v\r\n'<br>
            xx is a two character ASCII hexadecimal value from 00 to FF representing the I2C address<br>
            yy is a two character ASCII hexadecimal value from 00 to FF representing the I2C register<br>
            z is a one character ASCII hexadecimal value from 0 to 7 representing the bit to be read<br>
            v is a one character ASCII '0' or '1' representing the value of the bit that just got read<br>
            example: "##ib 32 7F 3 0\n\r" would be indicating a 0 from bit 3 of register 0x7F of address 0x32<br> 
    </td>
</tr>
<tr>
    <td>'ilxxyy'</td>
    <td>'##il xx yy vv\r\n'</td>
    <td>
        <b>Read One Byte From I2C Register</b><br>
        <b>Command:</b>'ilxxyy'<br>
            xx is a two character ASCII hexadecimal value from 00 to FF representing the I2C address<br>
            yy is a two character ASCII hexadecimal value from 00 to FF representing the I2C register<br>
            example: "il327F" would request a read of register 0x7F from I2C address 0x32<br>
        <b>Response:</b>'##il xx yy vv\r\n'<br>
            xx is a two character ASCII hexadecimal value from 00 to FF representing the I2C address<br>
            yy is a two character ASCII hexadecimal value from 00 to FF representing the I2C register<br>
            vv is a two character ASCII hexadecimal value from 00 to FF representing the value just read<br>
            example: "##il 32 7F F2\n\r" would be indicating a value of 0xF2 from register 0x7F of address 0x32<br> 
    </td>
</tr>
<tr>
    <td>'iLxxyy'</td>
    <td>'##iL xx yy vvvv\r\n'</td>
    <td>
        <b>Read Two Byte From I2C Register</b><br>
        <b>Command:</b>'iLxxyy'<br>
            xx is a two character ASCII hexadecimal value from 00 to FF representing the I2C address<br>
            yy is a two character ASCII hexadecimal value from 00 to FF representing the I2C register<br>
            example: "iL327F" would request a read of register 0x7F from I2C address 0x32<br>
        <b>Response:</b>'##iL xx yy vv\r\n'<br>
            xx is a two character ASCII hexadecimal value from 00 to FF representing the I2C address<br>
            yy is a two character ASCII hexadecimal value from 00 to FF representing the I2C register<br>
            vvvv is a four character ASCII hexadecimal value from 0000 to FFFF representing the value just read<br>
            example: "##iL 32 7F EF7D\n\r" would be indicating a value of 0xEF7D from register 0x7F of address 0x32<br> 
    </td>
</tr>
<tr>
	<td>'$Hs'</td><td></td><td>Start hard-iron calibration for compass</td>
</tr>
<tr>
	<td>'$He'</td><td></td><td>End hard-iron calibration for compass</td>
</tr>
<tr>
	<td>'$HdXXXXX'</td><td></td><td>Set compass deviation, X is in 10ths of a degree (-1800 to 1800)</td>
</tr>
<tr>
	<td>'$HvXXXXX'</td><td></td><td>Set compass variation, X is in 10ths of a degree (-1800 to 1800)</td>
</tr>
<tr>
	<td>'$Hp'</td><td></td><td>Print entire contents of IMU EEPROM</td>
</tr>
<tr>
	<td>'$Hh'</td><td></td><td>Print just compass heading</td>
</tr>
<tr>
	<td>'$Hc'</td><td></td><td>Clear deviation, variation, and hard-iron cal from compass EEPROM</td>
</tr>
<tr>
	<td>'$P1'</td><td>'#$P1'</td><td>Enable PicoC Background Mode (allows processing of SRV commands while PicoC program is running.)</td>
</tr>
<tr>
	<td>'$P2'</td><td>'#$P2'</td><td>Disable PicoC Background Mode</td>
</tr>
<tr>	
	<td>'$v1'</td><td>'#$v1'</td><td>Turn video streaming on (sends video frames without "I" command.)</td>
</tr>
<tr>
	<td>'$v2'</td><td>'#$v2'</td><td>Turn video straeming off</td>
</tr>
<tr>
	<td>'$Op1'</td><td>'#$Op1'</td><td>Turn Packet Mode on (see other documents for details)</td>
</tr>
<tr>
	<td>'$Op2'</td><td>'#$Op2'</td><td>Turn Packet Mode off</td>
</tr>
<tr>
	<td>'$Ov1'</td><td>'#$Ov1'</td><td>Turn video test mode #1 on (sends all 0xFFs for video frame)</td>
</tr>
<tr>
	<td>'$Ov2'</td><td>'#$Ov2'</td><td>Turn video test mode #1 off</td>
</tr>
<tr>
	<td>'$Ov3abcd'</td><td>'#$Ov3'</td><td>Set time between streaming video frames in ms (abcd is four-byte unsigned int sent as binary, LSB first.)</td>
</tr>
<tr>
	<td>'NActt'</td><td>'#NRA'</td>
	<td>
	<p>Stream analog input from RCM/RCM2. 'c' is a one byte binary analog channel number, and 'tt' is a two byte binary (LSB first) value which represents the time in milliseconds between sensor packets. Use 'tt' = 0x0000 to turn off streaming for analog channel 'c'. This command turns on streaming for analog channel 'c' every 'tt' milliseconds.</p>
	<p>The sensor data sent every 'tt' ms will consist of '#NAcaa' where 'c' is one byte binary analog channel and 'aa' is a two byte binary value (LSB first) representing the 12-bit analog value of channel 'c'.</p>
	</td>
</tr>
<tr>
	<td>'NDarbtt'</td><td>'#NRD'</td>
	<td>
	<p>Stream one bit from an I2C register.  'a' is a one byte binary I2C address to read. 'r' is a one byte binary I2C register to read (at address 'a'). 'b' is a one byte binary number from 0 to 7 indicating the bit to be read (from within register 'r') 'tt' is a two byte binary (LSB first) number, indicating the time in milliseconds between sensor streaming packet sends. If tt = 0 then streaming from this combination of I2C address and register is turned off.</p>
	<p>The sensor data sent every 'tt' ms will consist of '#NDarbv', where 'a', 'r' and 'b' are as above, and 'v' is the bianry value 0 or 1 representing the state of the digital input.</p>
    <p>This command is typically used to stream a single digital input's value back to the PC, although it can be used to read the state of any single bit in any I2C register at any I2C address.</p>
	</td>
</tr>
<tr>
	<td>'NBarbtt'</td><td>'#NRB'</td>
	<td>
	<p>Stream data from an I2C register.  'a' is a one byte binary I2C address to read. 'r' is a one byte binary I2C register to read (at address 'a'). 'b' is a one byte binary number indicating the number of bytes to be read (starting from register 'r') from 1 to 255. 'tt' is a two byte binary (LSB first) number, indicating the time in milliseconds between sensor streaming packet sends. If tt = 0 then streaming from this combination of I2C address and register is turned off.</p>
	<p>The sensor data sent every 'tt' ms will consist of '#NBarv1v2v3...', where 'a', 'r' and 'b' are as above, and 'v1' is the first byte returned from the I2C device, 'v2' is the second byte, 'v3' is the thrird, etc. If 'b' = 0x01, then there will only be one return value in the stream reply and it will look like '#NBarv'. The PC always knows how many bytes to expect back since it set up the stream with the 'b' parameter.</p>
    <p>This command is typically used to stream data when reading a single byte ('b' = 1) or multiple bytes from a single sensor ('b' > 1). For example, you could stream compass data from a HMC6352 compass at address 0x22, which requires 2 bytes of data to be read out, by setting up the steam as follows (raw hex bytes) : 0x4E 0x42 0x22 0x41 0x02 0x64 0x00. This would ask for a 2-byte read from address 0x22, register 0x41, every 100ms. If the current heading is 180 degrees, the resulting stream reply would look like this : 0x23 0x4E 0x42 0x22 0x41 0x07 0x08.
	</td>
</tr>
<tr>
	<td>'|'</td><td></td><td>If PicoC Bacground Mode is on, this command will interrupt a running PicoC program</td>
</tr>
<tr>
	<td>'B'</td><td></td><td>Execute a mini-PicoC program - can interrupt already runnign PicoC program. Send PicoC program, then termiante with ESC or Ctrl-C.</td>
</tr>
<tr>
	<td>'H'</td><td></td><td>Send Hokuyo data as ASCII</td>
</tr>
<tr>
	<td>'h'</td><td></td><td>Send Hokuyo data as binary</td>
</tr>
<tr>
	<td>'/'</td><td></td><td>Test command - send any bytes, terminate with ESC or ctrl-c, then SRV will echo those bytest back</td>
</tr>
<tr>
	<td>'$OKaaa'</td><td>'#$OK'</td>
    <td>
    Turn on or off SRV streaming shutdown. 'aaa' is a three byte ASCII decimal number from 000 to 255, and represents the number of seconds of 'quiet' (i.e. no data from PC to SRV) before shutting down all streaming data commands. Use 'aaa' of '000' to turn this feature off. Upon boot, the stream shutdown feature will be off.
    </td>
</tr>

<tr>
    <th></th>
    <th></th>
    <th></th>
</tr>
<tr>
    <th>C interpreter</th>
    <th></th>
    <th></th>
</tr>
<tr>
    <th></th>
    <th></th>
    <th></th>
</tr>
<tr>
    <td>Q</td>
    <td>##Leaving PicoC[CR][LF]</td>
    <td>
        <p>Execute C Program</p>
		<p>Runs the PicoC program stored in flash buffer, which got there via the 'E' line editor, the 'zr' or 'zRxx' command (which reads a flash sector into flash buffer) or 'X' command (XMODEM file transfer). PicoC program must have an exit(1); call to return control to the main firmware.</p>
		<p>When PicoC Background Mode mode is active (simultainous PicoC and Firmware commands), you must send a '|' character to get PicoC to exit before the exit(); call in the code. When PicoC Background Mode is not active (only PicoC running, Firmware commands ignored), you have to send an 'ESC' to terminate the PicoC program before the exit(); call runs.</p>
		<p>When PicoC exits, the SRV will send the string "##Leaving PicoC\r\n", which indicates to the client that the PicoC program exited normally.</p>
    </td>
</tr>
<tr>
    <td>'|'</td>
    <td></td>
    <td>
		<p>Break out of running PicoC program</p>
		<p>If a PicoC program is running and PicoC Background Mode is active, you can send the '|' character to the firmware and at the next statement, the PicoC program will exit and return "##Leaving PicoC\r\n".</p>
    </td>
</tr>
<tr>
    <td>'!'</td>
    <td></td>
    <td>
        <p>Run PicoC interactively</p>
		<p>Send ESC to exit.</p>
    </td>
</tr>
<tr>
    <td>'B'</td>
    <td></td>
    <td>
        <p>Send down short PicoC Program and run it</p>
		<p>After sending the 'B', send the text of the PicoC program. End the send with the ESC character (0x1B) or ctrl-c (0x03). The program will be immediately executed. Note that if another PicoC program is already running, this new PicoC program will run to completion, interrupting whatever the origonal PicoC program was doing. So make sure it doesn't take too long to execute. PicoC Background Mode must be turned on for this to work.</p>
    </td>
</tr>
<tr>
    <td>'$P?'</td>
    <td>'#P?0' or '#P?1'</td>
    <td>
        Report back how many PicoC programs are currently running. If none are running then this command will return #P?0. If one or more are runnning, then this command will return #P?1.
    </td>
</tr>
<tr>
    <td>'$P1'</td>
    <td>'#$P1'</td>
    <td>
        Enable parsing of firmware commands (these commands) during PicoC program execution. This is called PicoC Background Mode. This command turns it on. By default on bootup this mode is ON (starting with SRV firmware test28). When enabled, in between each PicoC command, the firmware will check to see if any new commands have been received by the PC and will execute them if so. If you run another PicoC program while executing an existing PicoC program, only two levels of PicoC are allowed. If you try to run a third level (using 'B' or 'Q') it will fail and report an error message. Note that any data that would normally go to the PicoC program from the PC will insted be diverted to the firmware command parser, and any data sent from the running PicoC program will get interspersed with any replies coming from the firmware in response to commands from the PC. 
    </td>
</tr>
<tr>
    <td>'$P2'</td>
    <td>'#$P2'</td>
    <td>
        Disable parsing of firmware commands (these commands) during PicoC program execution. This sets the SRV to operate as it did previous to version test28 - when running PicoC, firmware commands are ignored.
    </td>
</tr>
<tr>
    <td>'$x'</td>
    <td></td>
    <td>
        <p>Send PicoC program to alternate buffer</p>
		<p>If PicoC Background Mode is on, and you want to send down a second PicoC program to run, you need to send it to a different buffer than the normal 'flash buffer' since that is already being used by the already running PicoC program. So this command uses the XMODEM protocol (just like the 'X' command does) to send a file (PicoC program) to the alternate PicoC buffer. When you then exeute a 'Q' command, the alternate buffer is used as the source of the second-level PicoC program.</p>
    </td>
</tr>
<tr>
    <td>$P3a[CR]</td>
    <td>#$P3</td>
    <td>
		<p>Set buffered PicoC printf() mode</p>
		<p>Where 'a' is an ASCII '1' (for ENABLED) or ASCII '0' (for DISABLED)</p>
		<p>On boot, the buffered printf() mode is ENABLED ('a' = '1').</p>
		<p>When enabled, this option causes all printf() and output() calls to send their output to a buffered serial stream in the SRV's RAM. The contents of this buffer can be read out with the *R command (see below). The reason for this command is so that output from the PicoC program can be properly structured so that PC clients can undersand the difference between PicoC output and command responses for other commands, which may come back from the SRV interleaved with one another. When DISABLED, printf() and output() return to their normal functionality. Up to 64KB may be stored at once in this buffer before data is thrown out.</p>
    </td>
</tr>
<tr>
    <td>*B[CR]</td>
    <td>#B,[length],[buffer_data]</td>
    <td>
		<p>Read the contents of the PicoC printf() buffer and clear it</p>
		<p>This command causes the contents of the PicoC buffered serial stream (from printf() and output() calls in PicoC, when the buffered mode is enabled) to be send in the reply. Note that the reply can be up to 64KB long. After the entire contents of the buffer are sent in the reply, the buffer is cleared.<p>
		<p>[length] is an ASCII value from 0 to 65525 and it indicates the number of bytes in [buffer_data].</p>
		<p>[buffer_data] is the entire contents of the serial stream buffer, and can include any data bytes.</p>
    </td>
</tr>
<tr>
    <th colspan="3">PicoC Shared Memory</th>
</tr>
<tr>
    <td colspan="3">
        There are three shared variable arrays that are accessable from within a running PicoC program. Each array is 255 elements long. There is a string array (where each string can be 255 bytes long), an integer array, and a floating point value array. These arrays are global, and are not cleared between invocations of PicoC. The following six commands allow the PC to read/write from any of these shared variables while the PicoC program is running, thus allowing communication between the PC client and the running PicoC program. All accesses to the shared variable arrays are atomic from both PicoC and the PC sides. All of these commands are completely human readable as they are in ASCII. They can be entered from a terminal emulator. [CR] represents the single byte of 0x0D which is Carrige Return, and [LF] represents the single byte 0x0A which is Line Feed.
    </td>
<tr>
    <td>*W,S,[index],[value][CR]</td>
    <td>#WS</td>
    <td>
        Write string [value] into PicoC shared memory string number [index]. [value] is terminated by the [CR] but the [CR] will not be part of the string. Strings can be from zero to 255 bytes long. [index] can be from 0 to 255. For example, to write the value "Hi Mom!" into string 55, you would send '*WS55,Hi Mom![CR]'. This commands is in pure ASCII except that the string can by any series of bytes except [CR].
    </td>
</tr>
<tr>
    <td>*W,I,[index],[value][CR]</td>
    <td>#WI</td>
    <td>
        write integer [value] into PicoC shared memory integer number [index]. [value] is a signed integer from -2147483648 to 2147483647 (four byte signed integer value). [index] can be from 0 to 255. For example, to write the value 1234 into integer location 43, you would send '*W,I,43,1234[CR]'. This commands is in pure ASCII and [value] is termianted by [CR].
    </td>
</tr>
<tr>
    <td>*W,F,[index],[value][CR]</td>
    <td>#WF</td>
    <td>
        Write float [value] into PicoC shared memory float number [index]. [value] is any valid signle precision float value. [index] can be from 0 to 255. For example, to write the value 3.14159 into float location 110, you would send '*W,F,110,3.14159[CR]'. This commands is in pure ASCII and [value] is termianted by the [CR].
    </td>
</tr>
<tr>
    <td>*R,S,[index][CR]</td>
    <td>##R,S,[value][CR][LF]</td>
    <td>
        Read a string from PicoC shared memory string number [index]. [index] can be from 0 to 255. The SRV will respond with a packet that includes [value] which is the string requested. For example, if string number 24 contained "abcd hello!" then the command '*R,S,24[CR]' would return '##R,S,abcd hello![CR][LF]'.
    </td>
</tr>
<tr>
    <td>*R,I,[index][CR]</td>
    <td>##R,I,[value][CR][LF]</td>
    <td>
        Read an integer from PicoC shared memory integer number [index]. [index] can be from 0 to 255. The SRV will respond with a packet that includes [value] which is the integer requested. For example, if integer number 88 contained -1234567 then the command '*R,I,88[CR]' would return '##R,I,-1234567[CR][LF]'.
    </td>
</tr>
<tr>
    <td>*R,F,[index][CR]</td>
    <td>##R,F,[value][CR][LF]</td>
    <td>
        Read a float from PicoC shared memory float number [index]. [index] can be from 0 to 255. The SRV will respond with a packet that includes [value] which is the float requested. For example, if float number 244 contained 66.77888989 then the command '*R,F,244[CR]' would return '##R,F,66.77888989[CR][LF]'.
    </td>
</tr>

<tr>
    <td colspan="3">
    <p>Using the above two concepts of PicoC shared variables, and streaming, combined together they can perform
    a very powerful function on the SRV. The commands below show how to perform PicoC shared variable streaming.
    The basic concept is to send a single command that tells the SRV to send back a value (or more than one value)
    from the PicoC shared memory array every 'tt' milliseconds. Once this streaming command is sent to the SRV,
    the value of that variable will be sent back to the PC at that interval. This allows the PC to have a 'view'
    into the current state of the PicoC variables without having to poll using a '*R' command.</p>
    <p>These commands follow the same comma delimited human readable/writeable rules as the other PicoC shared
    memory commands so they are very easy to type and test from a terminal emulator.</p>
    </td>
</tr>

<tr>
    <td>NP,[a],[tt],[b],[c][CR]</td>
    <td>#NRP</td>
    <td>
        <p>[a] is one byte type:'F' (for float), 'I' (for integer) or 'S' (for string)</p>
        <p>[tt] is an ASCII number, from 0 to 65535, indicating the time
            in milliseconds between sensor streaming packet sends</p>
        <p>[b] is an ASCII start value from 0 to 255 indicating which 
            variable to start reading from (index)</p>
        <p>[c] is an ASCII end value from 0 to 255 indicating which variable 
            to end with (index) - this parameter is optional, and if not present, will just use [b]
            as the only variable streamed.</p>
        <p>Note that the commas are required beteween parameters, and that [CR] terminates the 
            command, and that the [c] parameter is optional.</p>
        <p>For example, this command "NP,F,2000,96[CR]" Would ask the SRV to generate a streaming 
            packet every 2 seconds consisting of the float variable at index 96.</p>
        <p>If [tt] = 0 then streaming from this combination of [a], [b] and [c] is turned off.</p>
    </td>
</tr>

<tr>
    <td colspan="3">
        <p align="center"><b>Replies</b></p>
        <p align="center">Streaming PicoC Shared Variable data reply formats</p>
        <p>The packet sent every [tt] milliseconds will consist of the following:</p>
    </td>
</tr>

<tr>
    <td colspan="2">##NP,F,[b],[f1],[f2],[f3],...[CR][LF]</td>
    <td>
        <p>For Float values:</p>
        <p>[b] is the starting index of [f1]</p>
        <p>[f1] is the first floating point value</p>
        <p>[f2] is the second floating point value (if present)</p>
        <p>[f3] through 'fn' are the rest of the floating point values (if present)</p>
        <p>So for a command "NP,F,2000,96,101[CR]" a streaming response packet might be:</p>
        <p>"##NP,F,96,2.15,-69291.2131,.6,10.0,.000012,99.99[CR][LF]"</p>
    </td>
</tr>
<tr>
    <td colspan="2">##NP,I,[b],[i1],[i2],[i3],...[CR][LF]</td>
    <td>
        <p>For Integer values:</p>
        <p>[b] is the starting index of [i1]</p>
        <p>[i1] is the first integer value</p>
        <p>[i2] is the second integer value (if present)</p>
        <p>[i3] through [in] are the rest of the integer values (if present)</p>
        <p>So for a command "NP,I,1000,41[CR]" a streaming response packet might be:</p>
        <p>"##NP,I,41,1234[CR][LF]"</p>
    </td>
</tr>
<tr>
    <td colspan="2">##NP,S,[b],[s1],[s2],[s3],...[CR][LF]</td>
    <td>
        <p>For String values:</p>
        <p>[b] is the starting index of [s1]</p>
        <p>[s1] is the first string</p>
        <p>[s2] is the second string(if present)</p>
        <p>[s3] through [sn] are the rest of the strings (if present)</p>
        <p>So for a command "NP,S,1000,15,16[CR]" a streaming response packet might be:</p>
        <p>"##NP,S,15,abc how are you? Fine!,Robot Has Died. Sensor 4 = 55.[CR][LF]"</p>
        <p>The main restriction  here is that you may not use commas or [LF] or [CR] in your 
        strings or the PC parser will get confused.</p>
    </td>
</tr>
<tr>
    <th colspan="3">
        See <a href="http://www.surveyor.com/C.html">www.surveyor.com/C.html</a> for full C interpreter documentation.
    </th>
</tr>
<tr>
    <th colspan="3">Packet Mode</th>
</tr>
<tr>
    <td>'$Op1'</td>
    <td>'#$Op1'</td>
    <td>
        Turns packet mode on. See Proposal for SRV1 Packet Communications document for details on packet mode. As of test46, this is the default at boot.
    </td>
</tr>
<tr>
    <td>'$Op2'</td>
    <td>'#$Op2'</td>
    <td>
        Turns packet mode off. As of test46, this is no longer the default mode on boot.
    </td>
</tr>
<tr>
    <td>Z</td>
    <td>##Z pkt mode off[CR][LF]</td>
    <td>
        Turns packet mode off. This command can be sent no matter if the SRV is in packet mode or not (just like the V command). The SRV will drop out of packet mode when it receives a Z, and THEN send the response. If you need to communicate with a robot from a terminal emulator (or any application that doesn't handle packet mode) you'll need to send this Z command right after each robot boot, since packet mode is now the default behavior.
    </td>
</tr>
<tr style="background-color:tan">
    <th colspan="3">SRV Special I2C functions</th>
</tr>
<tr style="background-color:tan">
    <td>I2C address 0x55</td>
    <td></td>
    <td>
        Autoincriment<br>
        The SRV will 'listen in' on certain I2C address. When a write or a read from these addresses happens, the SRV will take special action. The autoincriment address is 0x55. It only listens for writes to 0x55. Any I2C command (like "iw") can be used to write to these special I2C registers. The following resisters exist at this address, and can be written to:
    </td>
</tr>
<tr style="background-color:tan">
    <td></td>
    <td>0x01</td>
    <td>
        Autoincriment 1 Command Register: register 0x01, defaults to value 0x80<br>
        Writing to this register triggers the SRV to write new data to I2C address Autoincriment 1 Destination Address and register Autoincriment 1 Destination Register. These writes happen every 50ms. The data written will increase with every write if the value written to the Autoincriment 1 Command Register is greater than 0x80 (and at a rate proportional to how much beyond 0x80 the value is), and the data written will decrease if the value written to this register is less than 0x80 (and at a rate proportional to how much below 0x80 the value is). Once the data value gets to 0xFF or 0x00, it will no longer be written. To stop the data value from changing, write either 0x00 or 0x80 to this register. The initial value of the data is 0x00.
    </td>
</tr>
<tr style="background-color:tan">
    <td></td>
    <td>0x02</td>
    <td>
        Autoincriment 1 Destination Register: register 0x02, defaults to value 0x18<br>
    </td>
</tr>
<tr style="background-color:tan">
    <td></td>
    <td>0x03</td>
    <td>
        Autoincriment 1 Destination Address: register 0x03, defaults to value 0x2C<br>
    </td>
</tr>
<tr style="background-color:tan">
    <td></td>
    <td>0x11</td>
    <td>
        Autoincriment 2 Command Register: register 0x01, defaults to value 0x80<br>
        Writing to this register triggers the SRV to write new data to I2C address Autoincriment 2 Destination Address and register Autoincriment 2 Destination Register. These writes happen every 50ms. The data written will increase with every write if the value written to the Autoincriment 2 Command Register is greater than 0x80 (and at a rate proportional to how much beyond 0x80 the value is), and the data written will decrease if the value written to this register is less than 0x80 (and at a rate proportional to how much below 0x80 the value is). Once the data value gets to 0xFF or 0x00, it will no longer be written. To stop the data value from changing, write either 0x00 or 0x80 to this register. The initial value of the data is 0x00.
    </td>
</tr>
<tr style="background-color:tan">
    <td></td>
    <td>0x12</td>
    <td>
        Autoincriment 2 Destination Register: register 0x02, defaults to value 0x18<br>
    </td>
</tr>
<tr style="background-color:tan">
    <td></td>
    <td>0x13</td>
    <td>
        Autoincriment 2 Destination Address: register 0x03, defaults to value 0x2D<br>
    </td>
</tr>
</tbody>
</table>
<br>
Last updated 10 March 2014, valid for SRV firmware: SRV-1 GCC v1 Blackfin w/PicoC v2.1 built:xx:xx:xx - xxx xx 2012 v2.0test47
<br>
<br>Tan colored cells indicate a change since the last firmware version<br>
</body></html>